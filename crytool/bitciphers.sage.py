

# This file was *autogenerated* from the file bitciphers.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_8 = Integer(8); _sage_const_4096 = Integer(4096); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_3 = Integer(3); _sage_const_7 = Integer(7); _sage_const_6 = Integer(6); _sage_const_16 = Integer(16); _sage_const_1024 = Integer(1024)#############################################################################
# Sage module 'bitciphers.sage'                                             #
# ------------------------------------------------------------------------- #
# Klaus Pommerening (Johannes-Gutenberg-Universitaet Mainz)                 #
#   2014-Dec-31, last version 2015-Aug-11                                   #
#   2021-Jul-25: updated by be to reflect Sage 9.x and Python 3             #
#   2021-Oct-04: added method fsr of BoolF                                  #
# ------------------------------------------------------------------------- #
# This module is freeware. Use it as you like according to CTB licence.     #
# Usual disclaimers apply.                                                  #
#                                                                           #
# This file can be included to other Sage scripts via load() as here only   #
# functions are defined and these contain no print's (besides "print" is    #
# part of the function name).                                               #
#                                                                           #
# We refrain from defining a class "Bitblock", avoiding object oriented     #
# overhead and type conversion struggles.                                   #
#############################################################################

#############################################################################
##### Conversion routines for bitblocks #####################################
#############################################################################

def int2bbl(number,dim):
  """Converts number to bitblock of length dim via base-2 representation."""
  n = number                         # catch input
  b = []                             # initialize output
  for i in range(_sage_const_0 ,dim):
    bit = n % _sage_const_2                       # next base-2 bit
    b = [bit] + b                    # prepend
    n = (n - bit)//_sage_const_2 
  return b

def bbl2int(bbl):
  """Converts bitblock to number via base-2 representation."""
  ll = len(bbl)
  nn = _sage_const_0                              # initialize output
  for i in range(_sage_const_0 ,ll):
    nn = nn + bbl[i]*(_sage_const_2 **(ll-_sage_const_1 -i))   # build base-2 representation
  return nn

def str2bbl(bitstr):
  """Converts bitstring to bitblock."""
  ll = len(bitstr)
  xbl = []
  for k in range(_sage_const_0 ,ll):
    xbl.append(int(bitstr[k]))
  return xbl

def bbl2str(bbl):
  """Converts bitblock to bitstring."""
  bitstr = ""
  for i in range(_sage_const_0 ,len(bbl)):
    bitstr += str(bbl[i])
  return bitstr

def txt2bbl(text):
  """Converts ASCII-text to bitblock."""
  ll = len(text)
  xbl = []
  for k in range(_sage_const_0 ,ll):
    n = ord(text[k])
    by = int2bbl(n,_sage_const_8 )
    xbl.extend(by)
  return xbl  

def bbl2sub(bbl):
  """Converts bitblock to subset."""
  ll = len(bbl)
  set = []
  for i in range(_sage_const_0 ,ll):
    if (bbl[i] == _sage_const_1 ):
      set.append(i+_sage_const_1 )
  return set

def randsel(max,NN):
  """Generates NN different random integers between 0 and max."""
  rndlist = []
  while (len(rndlist) < NN):
    new = randint(_sage_const_0 ,max)
    if (not(new in rndlist)):
      rndlist.append(new)
  rndlist.sort()
  return rndlist

#############################################################################
##### Coincidence counter ###################################################
#############################################################################

def coinc(x,y):
  """Counts coincidences between 2 lists."""
  ll = len(x)
  assert ll <= len(y), "coinc_Error: Second bitblock too short."
  nn = _sage_const_0 
  for i in range(_sage_const_0 ,ll):
    if (x[i] == y[i]):
      nn += _sage_const_1 
  return nn

#############################################################################
##### Binary scalar product #################################################
#############################################################################

def binScPr(x,y):
  """Scalar product of two binary vectors (lists) mod 2."""
  l = len(x)
  assert l == len(y), "binScPr_Error: Blocks have different lengths."
  res = _sage_const_0 
  for i in range (_sage_const_0 ,l):
    res += x[i] * y[i]
  return res %_sage_const_2 

#############################################################################
##### XOR of bitblocks ######################################################
#############################################################################

def xor(plain,key):
  """Binary addition of bitblocks.
  Crops key if longer than plain.
  Repeats key if shorter than plain.
  """ 
  lk = len(key)
  lp = len(plain)
  ciph = []
  i = _sage_const_0 
  for k in range(_sage_const_0 ,lp):
    cbit = (plain[k] + key[i]) % _sage_const_2 
    ciph.append(cbit)
    i += _sage_const_1 
    if i >= lk:
      i = i-lk
  return ciph

#############################################################################
##### Matsui's test for linear cryptanalysis ################################
#############################################################################
# Input:  a and b are linear forms represented as bitlists.
#         pc is a list of pairs (argument, value).
#         compl specifies whether the resulting bit should be flipped.
# Output: t_0 is the number of zeroes in the test.
#         The second argument is the guessed key bit 0 or 1.
#         The third argument tells whether this guess is deterministic (True)
#           or randomized (False)
# ===> Caution: No error handling

def Matsui_Test(a, b, pc, compl = False):
  """Matsui's test for linear cryptanalysis"""
  N = len(pc)
  results = []
  for pair in pc:
    ax = binScPr(a,pair[_sage_const_0 ])
    by = binScPr(b,pair[_sage_const_1 ])
    result = (ax + by) % _sage_const_2 
    results.append(result)
  t = _sage_const_0 
  for bb in results:
    if bb == _sage_const_0 :
      t = t + _sage_const_1 
  if _sage_const_2 *t > N:
    if compl:
      return [t,_sage_const_1 ,True]
    else:
      return [t,_sage_const_0 ,True]
  elif _sage_const_2 *t < N:
    if compl:
      return [t,_sage_const_0 ,True]
    else:
      return [t,_sage_const_1 ,True]
  else:
    return [t,randint(_sage_const_0 ,_sage_const_1 ),False]

#############################################################################
##### Walsh transform #######################################################
#############################################################################

def wtr(nlist):
  """Walsh transform of a list of numbers"""
  max = _sage_const_4096                               # max dim = 12
  ll = len(nlist)
  assert ll <= max, "wtr_Error: Bitblock too long."
  dim = _sage_const_0                                  # dimension
  m = _sage_const_1                                    # 2**dimension
  while m < ll:
    dim = dim+_sage_const_1 
    m = _sage_const_2 *m
  assert ll == m, "wtr_Error: Block length not a power of 2."
  x = copy(nlist)                          # Initialize auxiliary bitblock
  y = copy(nlist)                          # Initialize auxiliary bitblock
  mi = _sage_const_1                                    # Actual power of 2
  for i in range(_sage_const_0 ,dim):                   # Binary recursion
    for k in range(_sage_const_0 ,ll):
      if ((k//mi) % _sage_const_2  == _sage_const_1 ):               # picks bit nr i
        y[k] = x[k-mi] - x[k]
      else:
        y[k] = x[k+mi] + x[k]
    for k in range(_sage_const_0 ,ll):
      x[k] = y[k]
    mi = _sage_const_2 *mi                               # Equals 2**i in the next step
  return x

#############################################################################
##### Class BoolF for Boolean functions #####################################
#############################################################################

class BoolF(object):
  """Boolean function
  Attribute: a list of bits describing the truth table of the function
  Attribute: the dimension of the domain"""

  __max = _sage_const_4096                               # max dim = 12

  def __init__(self,blist,method="TT"):
    """Initializes a Boolean function with a truth table
    or by its algebraic normal form if method is ANF."""
    ll = len(blist)
    assert ll <= self.__max, "BoolF_Error: Bitblock too long."
    dim = _sage_const_0                                  # dimension
    m = _sage_const_1                                    # 2**dim
    while m < ll:
      dim = dim+_sage_const_1 
      m = _sage_const_2 *m
    assert ll == m, "boolF_Error: Block length not a power of 2."
    self.__dim = dim
    if method=="TT":
      self.__tlist = blist
    else:
      self.__tlist=self.__convert(blist)

  def __convert(self,xx):
    """Converts a truth table to an ANF or vice versa."""
    x = copy(xx)                             # Initialize auxiliary bitblock
    y = copy(xx)                             # Initialize auxiliary bitblock
    mi = _sage_const_1                                    # Actual power of 2
    for i in range(_sage_const_0 ,self.__dim):                   # Binary recursion
      for k in range(_sage_const_0 ,_sage_const_2 **(self.__dim)):
        if ((k//mi) % _sage_const_2  == _sage_const_1 ): # picks bit nr i
          y[k] = (x[k-mi] + x[k]) % _sage_const_2  # XOR
        else:
          y[k] = x[k]
      for k in range(_sage_const_0 ,_sage_const_2 **(self.__dim)):
        x[k] = y[k]
      mi = _sage_const_2 *mi                               # Equals 2**i in the next step
    return x

  def getTT(self):
    """Returns truth table as bitlist."""
    return self.__tlist

  def valueAt(self,xx):
    """Evaluates Boolean function."""
    ll = len(xx)
    # assert ll == self.__dim, "boolF_Error: Block has false length."
    assert ll == self.__dim, str("boolF_Error: Block has false length (ll=%d; __dim=%d)." % (ll, self.__dim))
    index = bbl2int(xx)
    return self.__tlist[index]

  def getDim(self):
    """Returns dimension of definition domain."""
    return self.__dim

  def getANF(self):
    """Returns algebraic normal form as bitlist."""
    y = self.__convert(self.__tlist)
    return y

  def deg(self):
    """Algebraic degree of Boolean function"""
    y = self.__convert(self.__tlist)
    max = _sage_const_0 
    for i in range (_sage_const_0 ,len(y)):
      if y[i] != _sage_const_0 :
        b = int2bbl(i,self.__dim)
        wt = sum(b)
        if wt > max:
          max = wt
    return max

  def wspec(self):
    """Calculate Walsh spectrum."""
    ff = copy(self.__tlist)
    ll = len(ff)
    gg = []
    for i in range(_sage_const_0 ,ll):
      bit = ff[i]
      if (bit):
        gg.append(-_sage_const_1 )
      else:
        gg.append(_sage_const_1 )
    ff = wtr(gg)
    return ff

  def printTT(self):
    """Prints truth table to stdout."""
    for i in range(_sage_const_0 ,_sage_const_2 **(self.__dim)):
      bb = int2bbl(i,self.__dim)
      print( "Value at " + bbl2str(bb) + " is " + repr(self.__tlist[i]) )

  def printANF(self):
    """Prints algebraic normal form to stdout."""
    y = self.__convert(self.__tlist)
    for i in range(_sage_const_0 ,_sage_const_2 **(self.__dim)):
      monom = int2bbl(i,self.__dim)
      print( "Coefficient at " + bbl2str(monom) + " is " + repr(y[i]) )

  def fsr(self,u,n):
    """Generate a feedback shift register sequence
    using the actual Boolean function (repr. by self).
    Parameters: start vector u, number n of output bits.
    Caution: The vector u is modified by this function."""
    outlist = []
    for i in range (_sage_const_0 ,n):
      b = self.valueAt(u)
      c = u.pop()
      u.insert(_sage_const_0 ,b)    
      outlist.append(c)
    return outlist

#############################################################################
##### Class BoolMap for Boolean maps    #####################################
#############################################################################

class BoolMap(object):
  """Boolean map
  Attribute: a list of Boolean functions
  Attribute: the dimensions of domain and range"""

  __max = _sage_const_8                                 # max dim = 8

  def __init__(self,flist):
    """Initializes a Boolean map with a list of Boolean functions."""
    qq = len(flist)
    assert qq <= self.__max, "BoolMap_Error: Too many components."
    ll = len(flist[_sage_const_0 ].getTT())
    dim = _sage_const_0                                  # dimension
    m = _sage_const_1                                    # 2**dim
    while m < ll:
      dim = dim+_sage_const_1 
      m = _sage_const_2 *m
    assert ll == m, "BoolMap_Error: Block length not a power of 2."
    assert dim <= self.__max, "BoolMap_Error: Block length exceeds maximum."
    self.__dimd = dim
    self.__dimr = qq
    for i in range(_sage_const_1 ,qq):
      li = len(flist[i].getTT())
      assert li == ll,  "BoolMap_Error: Blocks of different lengths."
    self.__flist = flist

  def getFList(self):
    """Returns component list."""
    return self.__flist

  def getDim(self):
    """Returns dimension of preimage and image domain."""
    return [self.__dimd, self.__dimr]

  def getTT(self):
    """Returns truth table as list of bitlists."""
    nn = _sage_const_2 **(self.__dimd)
    qq = self.__dimr
    clist = []
    for j in range(_sage_const_0 ,qq):
      clist.append(self.__flist[j].getTT())
    transp = []
    for j in range(_sage_const_0 ,nn):
      trrow = []
      for i in range(_sage_const_0 ,qq):
        trrow.append(clist[i][j])
      transp.append(trrow)
    return transp

  def valueAt(self,xx):
    """Evaluates Boolean map."""
    ll = len(xx)
    assert ll == self.__dimd, "boolF_Error: Block has false length."
    index = bbl2int(xx)
    vlist = []
    for j in range(_sage_const_0 ,self.__dimr):
      vlist.append(self.__flist[j].getTT()[index])
    return vlist
    
  def getANF(self):
    """Returns algebraic normal form as list of bitlists."""
    return []  ##### To be specified

  def deg(self):
    """Algebraic degree of Boolean map"""
    return _sage_const_0   ##### To be specified

  def wspec(self):
    """Calculate Walsh spectrum."""
    dd = self.getDim()
    tt = self.getTT()
    m = _sage_const_2 **(dd[_sage_const_0 ])
    t = _sage_const_2 **(dd[_sage_const_1 ])
    nullv = [_sage_const_0 ] * t
    charF = []
    for k in range(_sage_const_0 ,m):
      charF.append(copy(nullv))
    for k in range(_sage_const_0 ,m):
      index = bbl2int(tt[k])
      charF[k][index] = _sage_const_1 
    blist = []
    for k in range(_sage_const_0 ,m):
      blist.extend(charF[k])
    speclist = wtr(blist)
    specmat = []
    for k in range(_sage_const_0 ,m):
      specmat.append(speclist[k*t:k*t+t])
    return specmat

  def linApprTable(self):
    """Calculate the linear approximation table."""
    lpr = self.wspec()
    dd = self.getDim()
    m = _sage_const_2 **(dd[_sage_const_0 ])
    t = _sage_const_2 **(dd[_sage_const_1 ])
    for k in range(_sage_const_0 ,m):
      for i in range(_sage_const_0 ,t):
        lpr[k][i] = (lpr[k][i] + m)//_sage_const_2 
    return lpr

  def linProf(self, extended=False):
    """Calculate linear profile.
    If extended is True, also calculate maximum potential and corresponding linear forms."""
    lpr = self.wspec()
    dd = self.getDim()
    m = _sage_const_2 **(dd[_sage_const_0 ])
    t = _sage_const_2 **(dd[_sage_const_1 ])
    for k in range(_sage_const_0 ,m):
      for i in range(_sage_const_0 ,t):
        lpr[k][i] = lpr[k][i] * lpr[k][i]
    if extended:
      flatlist = []
      for row in lpr:
        flatlist.extend(row)
      denominator = flatlist.pop(_sage_const_0 )
      mm = max(flatlist)
      ixlist = []
      for k in range(_sage_const_0 ,m):
        for i in range(_sage_const_0 ,t):
          if lpr[k][i] == mm:
            ixlist.append([k,i])
      return [lpr, mm, denominator, ixlist]
    else:
      return lpr

  def printTT(self):
    """Prints truth table to stdout."""
    nn = _sage_const_2 **(self.__dimd)
    qq = self.__dimr
    print("Dimensions of truth table:", nn, "by", qq)
    clist = []
    for j in range(_sage_const_0 ,qq):
      clist.append(self.__flist[j].getTT())
    transp = []
    for j in range(_sage_const_0 ,nn):
      trrow = []
      for i in range(_sage_const_0 ,qq):
        trrow.append(clist[i][j])
      transp.append(trrow)
    for j in range(_sage_const_0 ,nn):
      bb = int2bbl(j,self.__dimd)
      print("Value at", bb, "is", transp[j])

  def printANF(self):
    """Prints algebraic normal form to stdout."""
    pass     ##### To be specified

#############################################################################
##### S-boxes from Lucifer ##################################################
#############################################################################

#-------------- Define S0 ----------------------------
f1 = BoolF([_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ])
f2 = BoolF([_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ])
f3 = BoolF([_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ])
f4 = BoolF([_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ])
S0 = BoolMap([f1,f2,f3,f4])

#-------------- Define S0 inverse -------------------
fi1 = BoolF([_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ])
fi2 = BoolF([_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ])
fi3 = BoolF([_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ])
fi4 = BoolF([_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ])
S0inv = BoolMap([fi1,fi2,fi3,fi4])

#-------------- Define S1 ----------------------------
g1 = BoolF([_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ])
g2 = BoolF([_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ])
g3 = BoolF([_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ])
g4 = BoolF([_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ])
S1 = BoolMap([g1,g2,g3,g4])

#-------------- Define S1 inverse -------------------
gi1 = BoolF([_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ])
gi2 = BoolF([_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ])
gi3 = BoolF([_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ])
gi4 = BoolF([_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ])
S1inv = BoolMap([gi1,gi2,gi3,gi4])

def P(b):
  """Lucifer's bit permutation"""
  pb = [b[_sage_const_2 ],b[_sage_const_5 ],b[_sage_const_4 ],b[_sage_const_0 ],b[_sage_const_3 ],b[_sage_const_1 ],b[_sage_const_7 ],b[_sage_const_6 ]]
  return pb

def miniLuc(a,k,r):
  """Mini-Lucifer, encrypts 8-bit a with 16-bit key k over r rounds."""
  ll = len(a)
  assert ll == _sage_const_8 , "miniLuc_Error: Only blocks of length 8 allowed."
  lk = len(k)
  assert lk == _sage_const_16 , "miniLuc_Error: Only keys of length 16 allowed."
  k0 = k[_sage_const_0 :_sage_const_8 ]          # split into subkeys
  k1 = k[_sage_const_8 :_sage_const_16 ]
  aa = a               # round input
  # --- begin round
  for i in range(_sage_const_0 ,r): # round number is i+1
    # print("Round input =", aa)
    if (i % _sage_const_2  == _sage_const_0 ):   # select round key
      rndkey = k0
    else:
      rndkey = k1
    b = xor(aa,rndkey)     # add round key
    bleft = b[_sage_const_0 :_sage_const_4 ]         # begin substitution
    bright = b[_sage_const_4 :_sage_const_8 ]
    bbleft = S0.valueAt(bleft)
    bbright = S1.valueAt(bright)
    bb = bbleft + bbright  # end substitution
    if (i+_sage_const_1  == r):         # omit permutation in last round
      aa = bb
    else:
      aa = P(bb)
    # print("Round", i+1, ":", rndkey, b, bb, aa)
  # --- end round
  if (r % _sage_const_2  == _sage_const_0 ):         # add subkey after last round
    finkey = k0
  else:
    finkey = k1
  c = xor(aa,finkey)
  return c

#############################################################################
##### Class LFSR for Linear Feedback Shift Registers ########################
#############################################################################

class LFSR(object):
  """Linear Feedback Shift Register
  Generate a pseudo random bit stream with a linear feedback shift register.
  Attributes:
  - a list of bits (coeff) describing the taps of the register
  - the state setting the initial values (start) into the register
    (coeff and start must have the same length)
  - number n of output bits"""

  __max = _sage_const_1024                               # max length

  def __init__(self,blist):
    """Initializes a LFSR with a list of taps
    and the all 0 state."""
    ll = len(blist)
    assert ll <= self.__max, "LFSR_Error: Bitblock too long."
    self.__length = ll
    self.__taplist = blist
    self.__state = [_sage_const_0 ] * ll

  def __str__(self):
    """Defines a printable string telling the internals of
    the register."""
    outstr = "Length: " + str(self.__length)
    outstr += " | Taps: " + bbl2str(self.__taplist)
    outstr += " | State: " + bbl2str(self.__state)
    return outstr

  def getLength(self):
    """Returns the length of the LFSR."""
    return self.__length

  def setState(self,slist):
    """Sets the state."""
    sl = len(slist)
    # assert sl == self.__length, "LFSR_Error: Bitblock has wrong length."
    assert sl == self.__length, str("LFSR_Error: Bitblock (start vector) has wrong length (sl=%d; __length=%d)." % (sl, self.__length))
    self.__state = slist   # in Python use u = x.copy()

  def nextBits(self,n):
    """Returns the next n bits as a list (output) and updates the state."""
    outlist = []
    a = self.__taplist
    u = self.__state
    for i in range (_sage_const_0 ,n):
      b = binScPr(a,u)
      c = u.pop()
      u.insert(_sage_const_0 ,b)
      outlist.append(c)
    self.__state = u
    return outlist

